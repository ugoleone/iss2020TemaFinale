
System /*-trace*/ tearoom


// clientsmanager -> smartbell
Request 	notify 	: 	notify(X)

// smartbell -> clientsmanager
Reply		tempResult	:	tempResult(X)
Dispatch	accept	:	accept(ID)
Dispatch	inform	:	inform(ID,X)

// clientsmanager -> waiter
Dispatch order : order(ID,X)

// waiter -> resourcemodel
Dispatch orderReq : orderReq(ID,X) 

// web -> 
Event prepare : prepare(ID)

// barman -> resource model
Dispatch ready : ready(X) 

// clientsmanager -> waiter
Dispatch    payment : payment(ID,X)

// web -> 
Event newClient : newClient(X)
Event nextState : nextState(ID)


// waiter -> planner
Dispatch doMove     : doMove(V)
Request  movetoCell : movetoCell(X,Y)
Dispatch stopTask : stopTask(X)

// planner -> waiter
Reply    atcell     : atcell(X,Y)

// planner -> basicrobot
Dispatch cmd       	: cmd(MOVE)    
Request step : step(TIME)

// basicrobot -> planner
Reply stepdone : stepdone(X)
Reply stepfail : stepfail(X)

// auto-messaggi waiter
Dispatch moveTo : moveTo(X)
Dispatch returnHome : returnHome(X)
Dispatch listenRequests : listenRequests(X)
Dispatch cleanTable : cleanTable(T)

// waiter -> resourcemodel
Dispatch unlockClient : unlockClient(X)
Dispatch cleaningInterrupted : cleaningInterrupted(Time, T)
Dispatch taskDone : taskDone(T,X)
Dispatch timeoutClient : timeoutClient(T,X)
Request askWhere : askWhere(X)

// smartbell -> resourcemodel
Dispatch newClient : newClient(X)

// planner -> resourcemodel
Dispatch waiterCurrentPositionDirection : waiterCurrentPositionDirection(X,Y,D)

// resourcemodel -> waiter
Reply location : location(X,Y)

// resourcemodel ->
Event waiterTaskChangedEvent : waiterTaskChangedEvent(X,T)
Event waitingTimeEvent : waitingTimeEvent(ID,X)
Event newOrderEvent : newOrderEvent(X)
Event orderReadyEvent : orderReadyEvent(X)

// clientsmanager -> resourcemodel
Dispatch updateClientState : updateClientState(ID,R)
Request clientStateReq : clientStateReq(ID)

// resourcemodel -> clientsmanager
Reply clientStateRep : clientStateRep(ID, STATE)

// web -> resourcemodel
Dispatch move : move(X)
Dispatch state : state(X)

// -> timer
Dispatch startTimer : startTimer(ID,A,M,P,T)
Dispatch cancelTimer : cancelTimer(ID)

// timer ->
Dispatch alarm : alarm(ID)



Context ctxtearoom ip [ host= "localhost"   port= 8010 ] 
Context ctxbasicrobot ip [ host= "127.0.0.1" port= 8020]


ExternalQActor basicrobot context ctxbasicrobot


QActor resourcemodel context ctxtearoom{
	[#
		val MAXSTAYTIME = 600000 // quanto può stare al massimo un cliente
		val MAXWAITINGTIME = 600000 // quanto aspetterà max un cliente in attesa
		var RaspIP = "" // IP dove è in esecuzione il basicrobot (ha signficato solo se è su raspberry)
		var TeatableNumber = "" 
		var Teatable = ""
		var busy = false // indica se il waiter è intento ad eseguire un task
		var Task = ""
		var ID = "" // ID del cliente
	#]
	State s0 initial{
		println("[RESOURCE MODEL] STARTING, I will be soon ready to listen to changes!")
		solve( consult("sysRules.pl")	 ) 
		solve( consult("tearoom.pl"))
		// salvo l'IP del raspberry, serve alla pagina web
		[# solve("context(ctxbasicrobot,IP,_,_)","") #]
		[# RaspIP = getCurSol("IP").toString() #]
		
		solve(consult("tearoomkb.pl"))
		discardMsg Off
	}
	Goto listenToChanges
	
	State listenToChanges{
		//println("[RESOURCE MODEL] LISTENING...")
	} Transition t0 
			whenMsg newClient -> informChanges
			whenMsg ready -> informChanges
			whenMsg orderReq -> informChanges
			whenMsg waiterCurrentPositionDirection -> informChanges
			whenMsg updateClientState -> informChanges
			whenMsg taskDone -> informChanges
			whenRequest askWhere -> findLocation
			whenMsg move -> informChanges
			whenMsg state -> informChanges
			whenRequest clientStateReq -> returnClientState
			whenMsg alarm -> informChanges
			whenMsg unlockClient -> informChanges
			whenMsg cleaningInterrupted -> informInterruption
			whenMsg timeoutClient -> informInterruption
	
	State informChanges{
		
		// un nuovo cliente è arrivato
		onMsg(newClient : newClient(X)) {
			println("[RESOURCE MODEL] New Client")
			// aggiungo il cliente alla base di conoscenza.
			//L'ID viene dalla base di conoscenza stessa a partire da quanti clienti totali ci sono stati.
			solve(newClient(ID))
			[#
				ID = getCurSol("ID").toString()
			#]
			// controllo se c'è un tavolo libero
			solve(teatable(TeatableNumber,available,_,_))
	 		ifSolved {
	 			println("[RESOURCE MODEL] A table is free!")
	 			[# 
				TeatableNumber = getCurSol("TeatableNumber").toString()
				#]
				// riservo il tavolo al cliente anche se non è ancora seduto
				solve(reserveTable($TeatableNumber,$ID))
				// aggiorno lo stato del cliente
				solve(updateClientState($ID,entering,true))
				println("[RESOURCE MODEL] Waiter task updated: reachEntranceDoor")
				// cliente non deve aspettare
				emit waitingTimeEvent : waitingTimeEvent($ID,0)
				// controllo se waiter sta facendo altro
				if [#busy#] {
					// waiter impegnato, aggiungo task a quelli da fare
					solve(addTask(reachEntranceDoor,$TeatableNumber))
				} else {
					// waiter libero. Nuovo task per lui
					[# busy = true #]
					solve(updateWaiterTask(reachEntranceDoor))
					emit waiterTaskChangedEvent : waiterTaskChangedEvent(reachEntranceDoor,$TeatableNumber)
		 		}
	 		} else {
	 			// tutti i tavoli occupati. Cliente devi aspettare
	 			println("[RESOURCE MODEL] All tables are busy")
	 			solve(addWaitingClient($ID))
				emit waitingTimeEvent : waitingTimeEvent($ID,$MAXWAITINGTIME) 
		 	}		
		}
		// aggiorno stato cliente
		onMsg(updateClientState : updateClientState(ID,CS)){
			[#
				ID = payloadArg(0)
				val CS = payloadArg(1) // nuovo stato
				when(CS) {
					"ordering" -> {#]
						// aggiorno stato
						solve(updateClientState($ID,$CS,true))
						solve(teatableClientID(TeatableNumber,$ID))
						[# TeatableNumber = getCurSol("TeatableNumber").toString() #]
						if [#busy#] {
							solve(addTask(takingOrder,$TeatableNumber))
						} else {
							// waiter recati al tavolo del cliente per prendere ordine
							[# busy = true #]
							solve(updateWaiterTask(takingOrder))
							emit waiterTaskChangedEvent : waiterTaskChangedEvent(takingOrder,$TeatableNumber)
						}
					[#}
					"waitingtea" -> {#] 
						solve(updateClientState($ID,$CS,true))
					[#}
					"drinking" -> {#] 
						solve(updateClientState($ID,$CS,false))
					[#}
					"paying" -> {#]
						solve(updateClientState($ID,$CS,true))
						solve(teatableClientID(T, $ID))
						[# TeatableNumber = getCurSol("T").toString() #]
						if [#busy#] {
							solve(addTask(collectingPayment,$TeatableNumber))
						} else {
							// waiter recati al tavolo del cliente per prendere il pagamento
							[# busy = true #]
							solve(updateWaiterTask(collectingPayment))
							emit waiterTaskChangedEvent : waiterTaskChangedEvent(collectingPayment,$TeatableNumber)
						}
						
					[#}
					"exiting" -> {#]
						solve(updateClientState($ID,$CS,true))
					[#}
					"withdraw" -> {#]
						// cliente se ne è andato prima di entrare
						solve(withdraw)
						solve(exitClient($ID))
					[#}
				}
			#]
		}
		// nuovo ordine
		onMsg(orderReq : orderReq(ID,O)){
			[# 
				ID = payloadArg(0)
				val O = payloadArg(1)
			#]
			println("[RESOURCE MODEL] New order for client $ID")
			// aggiorno stato barman
			solve(updateBarmanState(preparing($ID,$O)))
			// aggiungo ordine alla base di conoscenza
			solve(addOrder($ID,$O,false))
			// barman prepara l'ordine per il cliente ID
			emit newOrderEvent : newOrderEvent($ID)
		}
		// ordine per il cliente ID pronto
		onMsg(ready : ready(ID)){
			[# ID = payloadArg(0)#]
			// aggiorno base di conoscenza
			solve(orderReady($ID))
			solve(client($ID,_,_))
			// controllo che il cliente sia ancora in sala. Potrebbe essere scattato MAXSTAYTIME
			ifSolved {
				println("[RESOURCE MODEL] Order is ready for client $ID")
				solve(updateBarmanState(ready($ID)))
				if [#busy#] {
					solve(addTask(collectingDrink,$ID))
				} else {
					// waiter vai a prendere il drink
					[# busy = true #]
					solve(updateWaiterTask(collectingDrink))
					emit waiterTaskChangedEvent : waiterTaskChangedEvent(collectingDrink,$ID)
				}
			} else {
				println("[RESOURCE MODEL] Order is ready for client $ID but he is gone")
				solve(updateBarmanState(idle))
				solve(deleteOrder($ID))
			}
		}
		// aggiorno posizione e direzione del waiter sulla base di conoscenza
		onMsg(waiterCurrentPositionDirection : waiterCurrentPositionDirection(X,Y,D)) {
			[# 
				val X = payloadArg(0)
				val Y = payloadArg(1)
				val D = payloadArg(2)
			#]
			solve(updateWaiterPositionDirection($X,$Y,$D))
		}
		// il waiter ha terminato un task
		onMsg(taskDone : taskDone(T,X)) {
			[# Task = payloadArg(0) #] // il task appena terminato
			[# when(Task) {
				"reachEntranceDoor" ->  { #]
				// un cliente è effettivamente entrato
				solve(enterClient)
				// ora portalo al tavolo
				solve(updateWaiterTask(convoyTable))
				emit waiterTaskChangedEvent : waiterTaskChangedEvent(convoyTable,0)
			[# } 
				"convoyTable" ->  {
			#] 
				[# TeatableNumber = payloadArg(1) #]
				solve(teatableClientID($TeatableNumber,ID))
				[# ID = getCurSol("ID").toString() #]
				// il cliente si è seduto
				solve(seatClient($TeatableNumber,$ID))
				// faccio partire il timer per segnare il staying time
				forward timersmanager -m startTimer : startTimer(0,resourcemodel, alarm, $ID, $MAXSTAYTIME)
				
				// controllo se ho pending task. In caso affermativo prendo il primo e lo faccio.
				// In caso negativo controllo se ho tavoli da sanificare. Se sì, sanifico.
				// Se no, torno a casa.
				// PROCEDURA RIPETUTA SPESSO nel codice
				solve(getTask(T,P))
				ifSolved {
					[# Task = getCurSol("T").toString() 
						var P = getCurSol("P").toString()
					#]
					solve(updateWaiterTask($Task))
					emit waiterTaskChangedEvent : waiterTaskChangedEvent($Task,$P)
				} else {
					solve(teatable(TeatableNumber,dirty,RemainingTime,_))
					[# busy = false #]
					ifSolved {
						[# 
							TeatableNumber = getCurSol("TeatableNumber").toString() 
							var RemainingTime = getCurSol("RemainingTime").toString()
							var Concat = "s" + TeatableNumber + "s" + RemainingTime
						#]
						solve(updateWaiterTask(sanitizing))
						emit waiterTaskChangedEvent : waiterTaskChangedEvent(sanitizing,$Concat)
					} else {
						solve(updateWaiterTask(returnHome))
						emit waiterTaskChangedEvent : waiterTaskChangedEvent(returnHome,0)
					}
				}
			[# } 
				"returnHome" ->  {
			#] 
				solve(updateWaiterTask(athome))
			[# } 
				"takingOrder" ->  {
			#] 
				solve(getTask(T,P))
				ifSolved {
					[# Task = getCurSol("T").toString() 
						var P = getCurSol("P").toString()
					#]
					solve(updateWaiterTask($Task))
					emit waiterTaskChangedEvent : waiterTaskChangedEvent($Task,$P)
				} else {
					solve(teatable(TeatableNumber,dirty,RemainingTime,_))
					[# busy = false #]
					ifSolved {
						[# 
							TeatableNumber = getCurSol("TeatableNumber").toString() 
							var RemainingTime = getCurSol("RemainingTime").toString()
							var Concat = "s" + TeatableNumber + "s" + RemainingTime
						#]
						solve(updateWaiterTask(sanitizing))
						emit waiterTaskChangedEvent : waiterTaskChangedEvent(sanitizing,$Concat)
					} else {
						solve(updateWaiterTask(returnHome))
						emit waiterTaskChangedEvent : waiterTaskChangedEvent(returnHome,0)
					}
				}
			[# } 
				"collectingDrink" ->  {
			#] 
				[# ID = payloadArg(1) #]
				// ho preso il drink dal barman
				solve(deleteOrder($ID))
				solve(teatableClientID(TeatableNumber,$ID))
				[# TeatableNumber = getCurSol("TeatableNumber").toString() #]
				solve(updateBarmanState(idle))
				// lo porto al cliente
				solve(updateWaiterTask(bringingDrinkToClient))
				emit waiterTaskChangedEvent : waiterTaskChangedEvent(bringingDrinkToClient,$TeatableNumber)
			[# } 
				"bringingDrinkToClient" ->  {
			#] 
				[# TeatableNumber = payloadArg(1) #]
				solve(teatableClientID($TeatableNumber,ID))
				[# ID = getCurSol("ID").toString() #]
				solve(updateClientState($ID,drinking,false))
				solve(getTask(T,P))
				ifSolved {
					[# Task = getCurSol("T").toString() 
						var P = getCurSol("P").toString()
					#]
					solve(updateWaiterTask($Task))
					emit waiterTaskChangedEvent : waiterTaskChangedEvent($Task,$P)
				} else {
					solve(teatable(TeatableNumber,dirty,RemainingTime,_))
					[# busy = false #]
					ifSolved {
						[# 
							TeatableNumber = getCurSol("TeatableNumber").toString() 
							var RemainingTime = getCurSol("RemainingTime").toString()
							var Concat = "s" + TeatableNumber + "s" + RemainingTime
						#]
						solve(updateWaiterTask(sanitizing))
						emit waiterTaskChangedEvent : waiterTaskChangedEvent(sanitizing,$Concat)
					} else {
						solve(updateWaiterTask(returnHome))
						emit waiterTaskChangedEvent : waiterTaskChangedEvent(returnHome,0)
					}
				}
				// aggiorno i tea serviti
				solve(serveTea)
			[# } 
				"collectingPayment" ->  {
			#] 
				solve(teatableClientID(T, $payloadArg(1)))
				[# TeatableNumber = getCurSol("T").toString() #]
				solve(updateWaiterTask(convoyExit))
				// libero il tavolo
				solve(freeTable($TeatableNumber))
				emit waiterTaskChangedEvent : waiterTaskChangedEvent(convoyExit,$payloadArg(1))
			[# } 
				"convoyExit" ->  {
			#] 
				[# ID = payloadArg(1) #]
				// il cliente è effettivamente uscito
				solve(exitClient($ID)) 
				solve(getTask(T,P))
				ifSolved {
					[# Task = getCurSol("T").toString() 
						var P = getCurSol("P").toString()
					#]
					solve(updateWaiterTask($Task))
					emit waiterTaskChangedEvent : waiterTaskChangedEvent($Task,$P)
				} else {
					solve(teatable(TeatableNumber,dirty,RemainingTime,_))
					[# busy = false #]
					ifSolved {
						[# 
							TeatableNumber = getCurSol("TeatableNumber").toString() 
							var RemainingTime = getCurSol("RemainingTime").toString()
							var Concat = "s" + TeatableNumber + "s" + RemainingTime
						#]
						solve(updateWaiterTask(sanitizing))
						emit waiterTaskChangedEvent : waiterTaskChangedEvent(sanitizing,$Concat)
					} else {
						solve(updateWaiterTask(returnHome))
						emit waiterTaskChangedEvent : waiterTaskChangedEvent(returnHome,0)
					}
				}
			[# } 
				"sanitizing" ->  {
			#]  
				[#
				TeatableNumber = payloadArg(1)
				#]
				// aggiorno base di conoscenza specificando il tavolo pulito
				solve(teatableCleaned($TeatableNumber))
				// controllo se ci sono clienti in attesa di entrare
				solve(getWaitingClient(ID))
				ifSolved {
					// porto cliente al tavolo
					[# ID = getCurSol("ID").toString() #]
					solve(reserveTable($TeatableNumber,$ID))
					solve(updateClientState($ID,entering,true))
					println("[RESOURCE MODEL] Waiter task updated: reachEntranceDoor")
					[# busy = true #]
					solve(updateWaiterTask(reachEntranceDoor))
					emit waiterTaskChangedEvent : waiterTaskChangedEvent(reachEntranceDoor,$TeatableNumber)
				} else {
					solve(getTask(T,P))
					ifSolved {
						[# Task = getCurSol("T").toString() 
							var P = getCurSol("P").toString()
						#]
						solve(updateWaiterTask($Task))
						emit waiterTaskChangedEvent : waiterTaskChangedEvent($Task,$P)
					} else {
						solve(teatable(TeatableNumber,dirty,RemainingTime,_))
						[# busy = false #]
						ifSolved {
							[# 
								TeatableNumber = getCurSol("TeatableNumber").toString() 
								var RemainingTime = getCurSol("RemainingTime").toString()
								var Concat = "s" + TeatableNumber + "s" + RemainingTime
							#]
							solve(updateWaiterTask(sanitizing))
							emit waiterTaskChangedEvent : waiterTaskChangedEvent(sanitizing,$Concat)
						} else {
							solve(updateWaiterTask(returnHome))
							emit waiterTaskChangedEvent : waiterTaskChangedEvent(returnHome,0)
						}
					}
				}
			[#}
				"forceExit" -> {#]
					// ho fatto alzare il cliente, ora lo porto all'uscita
					[#
					TeatableNumber = payloadArg(1)
					#]
					solve(freeTable($TeatableNumber))
					solve(teatableClientID($TeatableNumber,ID))
					[# ID = getCurSol("ID").toString() #]
					emit waiterTaskChangedEvent : waiterTaskChangedEvent(convoyExit,$ID)
				[#}
			}#]	
			
		}
		// controllo manuale del waiter
		onMsg(move : move(X)){
			[# 
				val Task = payloadArg(0)
				when(Task) {
					"stepAhead" -> {#]
						solve(updateWaiterTask(stepAhead))
						emit waiterTaskChangedEvent : waiterTaskChangedEvent(stepAhead,0)
					[#}
					"turnLeft" -> {#]
						solve(updateWaiterTask(turnLeft))
						emit waiterTaskChangedEvent : waiterTaskChangedEvent(turnLeft,0)
					[#}
					"turnRight" -> {#]
						solve(updateWaiterTask(turnRight))
						emit waiterTaskChangedEvent : waiterTaskChangedEvent(turnRight,0)
					[#}
					"returnHome" -> {#]
						[# busy = false #]
						solve(updateWaiterTask(returnHome))
						emit waiterTaskChangedEvent : waiterTaskChangedEvent(returnHome,0)
					[#}
				}
			#]
		}
		// ricevuto alarm dal timersmanager. Signfica che è scaduto il maxstaytime per un cliente
		onMsg(alarm : alarm(ID)) {
			[# var served = true 
				ID = payloadArg(0)
			#]
			solve(client($ID,ClientState,L))
			// controllo che il cliente non se ne sia già andato
			ifSolved {
				[# var clientState = getCurSol("ClientState").toString() #]
				// se il cliente sta pagando o sta uscendo non ha senso forzare l'uscita
				if [# clientState != "paying" && clientState != "exiting" #] {
					solve(teatableClientID(T, $ID))
					[# TeatableNumber = getCurSol("T").toString() #]
					// controllo se è stato servito. Se sì dovrà pagare
					if [#clientState == "ordering" || clientState == "entering"#]{
						[# served = false #]
					}
					if [#busy#] {
						if [#served#] {
							solve(addTask(collectingPayment,$TeatableNumber))	
							solve(updateClientState($ID,paying,true))
							[#println(served)#]
						} else {
							solve(addTask(forceExit,$TeatableNumber))	
							solve(updateClientState($ID,exiting,true))
						}
					} else {
						[# busy = true #]
						if [#served#] {
							// il cliente è stato servito. Forzo l'uscita facendolo pagare
							solve(updateClientState($ID,paying,true))
							solve(updateWaiterTask(collectingPayment))
							emit waiterTaskChangedEvent : waiterTaskChangedEvent(collectingPayment,$TeatableNumber)
						} else {
							// il cliente non è stato servito. Vado da lui per farlo alzare
							solve(updateClientState($ID,exiting,true))
							solve(updateWaiterTask(forceExit))
							emit waiterTaskChangedEvent : waiterTaskChangedEvent(forceExit,$TeatableNumber)
						}
						
					}	
				}
			
			}
		}
		// sblocco il bottone sulla pagina web
		onMsg(unlockClient : unlockClient(P)) {
			[# TeatableNumber = payloadArg(0) #]
			solve(teatableClientID($TeatableNumber,ID))
			[# var ID = getCurSol("ID").toString() #]
			solve(unlockClient($ID))
		}
		
		// prendo lo stato dalla base di conoscenza e lo invio alla pagina web
		solve(roomstate(S,Y,X,D,T1,T2,SD,O,CS,TS,NC,CR,W))
		[# 	
			val S = getCurSol("S").toString()
			val X = getCurSol("X").toString()
			val Y = getCurSol("Y").toString()
			val D = getCurSol("D").toString()
			val T1 = getCurSol("T1").toString()
			val T2 = getCurSol("T2").toString()
			val SD = getCurSol("SD").toString()
			val O = getCurSol("O").toString()
			val CS = getCurSol("CS").toString()
			val TS = getCurSol("TS").toString()
			val NC = getCurSol("NC").toString()
			val CR = getCurSol("CR").toString()
			val W = getCurSol("W").toString()
			
			
			val JsonState : String = itunibo.formatter.formatterUtil.formatJson(S,X,Y,D,T1,T2,SD,O,CS,TS,NC,CR,W,RaspIP)
		#]
		
		updateResource [# JsonState #]
		
	} Goto listenToChanges
	
	State findLocation {
		// rispondo ad una richiesta di posizione
		onMsg(askWhere : askWhere(X)){
			[# var Spot = payloadArg(0) #]
			println("[RESOURCE MODEL] Find location $Spot")
			solve(pos($Spot,X,Y))
			[# 
			val X = getCurSol("X").toString() 
		  	val Y = getCurSol("Y").toString()
			#]
			replyTo askWhere with location : location($X,$Y)
		}
	}Goto listenToChanges
	
	State returnClientState {
		// rispondo ad una richiesta per sapere lo stato di un cliente
		onMsg(clientStateReq : clientStateReq(ID)) {
			[# ID = payloadArg(0) #]
			solve(client($ID,S,L))
			[# val S = getCurSol("S").toString()#]
			replyTo clientStateReq with clientStateRep : clientStateRep($ID,$S)
		}
		
	}Goto listenToChanges
	
	State informInterruption {
		// stato legato all'interruzione di task
		onMsg(cleaningInterrupted : cleaningInterrupted(Time, T)) {
			// pulizia interrotta
			[# 
				var RemainingTime = payloadArg(0) 
				TeatableNumber = payloadArg(1)
			#]
			// aggiorno il tavolo col nuovo tempo di pulizia
			solve(replaceRule(teatable($TeatableNumber,_,_,CS),teatable($TeatableNumber,dirty,$RemainingTime,CS)))
		}
		onMsg(timeoutClient : timeoutClient(T,X)) {
			// cliente ci ha messo troppo ad ordinare o pagare
			[# 
				Task = payloadArg(0) 
				TeatableNumber = payloadArg(1)
			#]
			solve(teatableClientID($TeatableNumber, ID))
			[# var ID = getCurSol("ID").toString() #]
			solve(client($ID,S,_))
			[# var S = getCurSol("S").toString() #]
			if [# S == "ordering" || S == "paying"#] {
				// faccio regredire il cliente allo stato precedente
				solve(nextState(PreviousState,$S))
				[# var PS = getCurSol("PreviousState").toString() #]
				solve(updateClientState($ID,$PS,false))	
			}
			solve(getTask(T,P))
			ifSolved {
				[# Task = getCurSol("T").toString() 
					var P = getCurSol("P").toString()
				#]
				solve(updateWaiterTask($Task))
				emit waiterTaskChangedEvent : waiterTaskChangedEvent($Task,$P)
			} else {
				solve(teatable(TeatableNumber,dirty,RemainingTime,_))
				[# busy = false #]
				ifSolved {
					[# 
						TeatableNumber = getCurSol("TeatableNumber").toString() 
						var RemainingTime = getCurSol("RemainingTime").toString()
						var Concat = "s" + TeatableNumber + "s" + RemainingTime
					#]
					solve(updateWaiterTask(sanitizing))
					emit waiterTaskChangedEvent : waiterTaskChangedEvent(sanitizing,$Concat)
				} else {
					solve(updateWaiterTask(returnHome))
					emit waiterTaskChangedEvent : waiterTaskChangedEvent(returnHome,0)
				}
			}	
		}
		solve(roomstate(S,Y,X,D,T1,T2,SD,O,CS,TS,NC,CR,W))
		[# 	
			val S = getCurSol("S").toString()
			val X = getCurSol("X").toString()
			val Y = getCurSol("Y").toString()
			val D = getCurSol("D").toString()
			val T1 = getCurSol("T1").toString()
			val T2 = getCurSol("T2").toString()
			val SD = getCurSol("SD").toString()
			val O = getCurSol("O").toString()
			val CS = getCurSol("CS").toString()
			val TS = getCurSol("TS").toString()
			val NC = getCurSol("NC").toString()
			val CR = getCurSol("CR").toString()
			val W = getCurSol("W").toString()
			
			
			val JsonState : String = itunibo.formatter.formatterUtil.formatJson(S,X,Y,D,T1,T2,SD,O,CS,TS,NC,CR,W,RaspIP)
		#]
		
		updateResource [# JsonState #]
	}Goto listenToChanges
}

QActor waiter context ctxtearoom{ 
	
	[# 
		var WhatImDoing = "athome" // cosa sto facendo
		var TeatableNumber = ""
		var Teatable = ""
		var Misc = "" // payload
		var StartCleaning = 0L // quando ho iniziato a pulire
		var CleaningTime = 0L // quanto ho pulito
		var RemainingTime = 0L // quanto manca da pulire
		var ActiveTimer = 0L // ID del timer attivo
		var ReturningHome = false // indicazione se sto tornando a casa
		var TeatableToClean = ""
		var TeatableNumberToClean = ""
		var WasCleaning = false // indicazione se sto pulendo
	#]
	
	State s0 initial{ 
		println("[WAITER] waiter is starting..I'm HOME!") 
		discardMsg Off
	} 
	Goto reqHandler
	
 	State reqHandler{
 		println("[WAITER] Waiting for a request!")
 	}
 	Transition t0 
 		whenEvent waiterTaskChangedEvent -> handleChange
 		whenMsg moveTo -> movementHelper
 		whenMsg returnHome -> returnHomeState
 		
 	State handleChange {
 		// nuovo task
 		onMsg(waiterTaskChangedEvent : waiterTaskChangedEvent(T,X)) {
 			// se stavo tornando a casa e ho ricevuto un nuovo task, devo fermare il movimento ed eseguirlo
 			if [# ReturningHome #] {
 				forward planner -m stopTask : stopTask(0)
 				[# ReturningHome = false #]
 			}
 			// se stavo pulendo e ho ricevuto un nuovo task, devo aggiornare il RemainingTime di quel tavolo ed eseguire il task
 			[#
 			if(WasCleaning) {
				CleaningTime = System.currentTimeMillis() - StartCleaning
				if(CleaningTime < RemainingTime){
					//non ho finito di pulire il tavolo
					RemainingTime = RemainingTime - CleaningTime
					WasCleaning = false
					#]
					// cancello il timer legato a quanto devo pulire
					forward timersmanager -m cancelTimer : cancelTimer($ActiveTimer)
					// notifico al resourcemodel l'interruzione
					forward resourcemodel -m cleaningInterrupted : cleaningInterrupted($RemainingTime,$TeatableNumberToClean)
					[#
				}
			}
 			#]
 			[# 
 			// aggiorno cosa sto facendo
			WhatImDoing = payloadArg(0)
			Misc = payloadArg(1)
			if(Misc == "1" || Misc == "2") {
				TeatableNumber = Misc
				Teatable = "teatable" + TeatableNumber
			}
			if(WhatImDoing == "sanitizing") {
				TeatableNumberToClean = Misc.split('s')[1]
				TeatableToClean = "teatable" + TeatableNumberToClean
				RemainingTime = Misc.split('s')[2].toLong()
			}
 			#]
 			println("[WAITER] New task: $WhatImDoing")
 			
 			[#
			when(WhatImDoing) {
				"reachEntranceDoor" -> {#]
					forward waiter -m moveTo : moveTo(entrancedoor)
				[#}
				"convoyTable" -> {#]
					forward waiter -m moveTo : moveTo($Teatable)
				[#}
				"takingOrder" -> {#]
					forward waiter -m moveTo : moveTo($Teatable)
				[#}
				"collectingDrink" -> {#]
					 forward waiter -m moveTo : moveTo(barman)
				[#}
				"bringingDrinkToClient" -> {#]
					forward waiter -m moveTo : moveTo($Teatable)
				[#}
				"collectingPayment" -> {#]
					forward waiter -m moveTo : moveTo($Teatable)
				[#}
				"convoyExit" -> {#]
					forward waiter -m moveTo : moveTo(exitdoor)
				[#}
				"returnHome" -> {#]
					forward waiter -m returnHome : returnHome(home)
				[#}	
				"sanitizing" -> {#]
					forward waiter -m moveTo : moveTo($TeatableToClean)
				[#}
	
	
				"stepAhead" -> {#]
					forward planner -m doMove : doMove(w)
				[#}
				"turnLeft" -> {#]
					forward planner -m doMove : doMove(l)
				[#}
				"turnRight" -> {#]
					forward planner -m doMove : doMove(r)
				[#}
					
				"forceExit" -> {#]
					forward waiter -m moveTo : moveTo($Teatable)
				[#}
 			}#]
 		}
 	}Goto reqHandler 
	
	
	State takingOrder {
		onMsg(order : order(ID, O)) {
			// ho ricevuto l'ordine del cliente 
			// cancello il timer
			forward timersmanager -m cancelTimer : cancelTimer($ActiveTimer)
			[# var ID = payloadArg(0) 
				var O = payloadArg(1)
			#]
			// notifico l'ordine al resourcemodel
			forward resourcemodel -m orderReq : orderReq( $ID, $O )
			forward resourcemodel -m taskDone : taskDone($WhatImDoing,0)
		}
	} 
	Goto reqHandler
	
	
	State handlePayment {
		onMsg(payment : payment( ID, MONEY )){
			// ho ricevuto pagamente dal cliente
			// cancello timer
			forward timersmanager -m cancelTimer : cancelTimer($ActiveTimer)
			[# println("[WAITER] " + payloadArg(0) + " EUR collected! Have a nice day!") #]
			forward resourcemodel -m taskDone : taskDone($WhatImDoing,$payloadArg(0))
		}
		
	}
	Goto reqHandler
	
	State cleaningTable{
		onMsg(cleanTable : cleanTable(T)) {
			[#TeatableNumberToClean = payloadArg(0)#]
			println("[WAITER] Cleaning $TeatableToClean!")
			[#
				StartCleaning = System.currentTimeMillis()
				ActiveTimer = StartCleaning
				WasCleaning = true
			#]
			// faccio partire il timer di pulizia del tavolo
			forward timersmanager -m startTimer : startTimer($ActiveTimer,waiter,alarm,$TeatableNumberToClean,$RemainingTime)
		}
	}Transition t0 	whenMsg alarm -> endCleaning
					whenEvent waiterTaskChangedEvent -> handleChange
					
	State endCleaning {
		onMsg(alarm : alarm(P)) {
			// finito il timer = finita la pulizia
			[#TeatableNumberToClean = payloadArg(0)#]
			forward resourcemodel -m taskDone : taskDone(sanitizing,$TeatableNumberToClean)
		}
	}Goto reqHandler
	
	State handleAlarm {
		println("[WAITER] Client timeout!")
		onMsg(alarm : alarm(P)) {
			// informo il resourcemodel dell'avvenuto timeout del cliente
			[#TeatableNumber = payloadArg(0)#]
			forward resourcemodel -m timeoutClient : timeoutClient($WhatImDoing,$TeatableNumber)
		}
	}Goto reqHandler
	
	
	// Stati legati al movimento
	
	State returnHomeState {
		onMsg(returnHome : returnHome(L)){
			[#val Location = payloadArg(0)#]
			request resourcemodel -m askWhere : askWhere($Location)
		}
		onMsg (location : location(X,Y)) {
			[# 
				val XT = payloadArg(0)
			   	val YT = payloadArg(1)			  
			 #]
			request planner -m movetoCell : movetoCell($XT,$YT)
			[# ReturningHome = true #]
		}
	}Transition t1 	whenEvent waiterTaskChangedEvent -> handleChange // se sto tornando a casa sono sensibile a nuovi task
					whenReply location -> returnHomeState
					whenReply atcell -> handleAtCell
					
	
	State movementHelper {
		onMsg(moveTo : moveTo(L)){
			[#val Location = payloadArg(0)#]
			// chiedo al resourcemodel la cella dove si trova Location
			request resourcemodel -m askWhere : askWhere($Location)
		}
		onMsg (location : location(X,Y)) {
			[# 
				val XT = payloadArg(0)
			   	val YT = payloadArg(1)			  
			 #]
			request planner -m movetoCell : movetoCell($XT,$YT)
		}
	}Transition t1 	whenReply location -> movementHelper
					whenReply atcell -> handleAtCell
					

	State handleAtCell { 
		onMsg(atcell : atcell(X,Y)){
			// sono arrivato ad un cella
			[# 
				var Col = payloadArg(0).toInt()
				var Row = payloadArg(1).toInt()
			#]
			[# when(WhatImDoing) {
				"convoyTable" -> {
			#] 
				if [#(Col==2 && Row==2) || (Col==4 && Row==2)#] {
					// sblocco il cliente per chiedere di ordinare
					forward resourcemodel -m unlockClient : unlockClient($TeatableNumber)
					forward waiter -m listenRequests : listenRequests(1)
					forward resourcemodel -m taskDone : taskDone($WhatImDoing,$TeatableNumber)
				}
			[# } 
				"takingOrder" ->  {
			#] 
				if [#(Col==2 && Row==2) || (Col==4 && Row==2)#] {
					// faccio partire il timer per dare un max time di ordinazione
					[# ActiveTimer = System.currentTimeMillis() #]
					forward timersmanager -m startTimer : startTimer($ActiveTimer,waiter,alarm,$TeatableNumber,10000)
					// sblocco il cliente per farlo ordinare
					forward resourcemodel -m unlockClient : unlockClient($TeatableNumber)
				}
			[# }
				"collectingDrink" ->  {
			#] 
				if [#Col==5 && Row==0#] {
					forward waiter -m listenRequests : listenRequests(1)
					forward resourcemodel -m taskDone : taskDone($WhatImDoing,$Misc)
				}
			[# }
				"bringingDrinkToClient" ->  {
			#] 
				if [#(Col==2 && Row==2) || (Col==4 && Row==2)#] {
					forward waiter -m listenRequests : listenRequests(1)
					forward resourcemodel -m taskDone : taskDone($WhatImDoing,$TeatableNumber)
				}
			[# }
				"collectingPayment" ->  {
			#] 
				if [#(Col==2 && Row==2) || (Col==4 && Row==2)#] {
					// attivo timer max time pagamento
					[# ActiveTimer = System.currentTimeMillis() #]
					forward timersmanager -m startTimer : startTimer($ActiveTimer,waiter,alarm,$TeatableNumber,10000)
					// sblocco il cliente per farlo pagare
					forward resourcemodel -m unlockClient : unlockClient($TeatableNumber)
				}
			[# } 
				"sanitizing" ->  {
			#]  
				if [#(Col==2 && Row==2) || (Col==4 && Row==2)#] {
					forward waiter -m cleanTable : cleanTable($TeatableNumberToClean)
				}
			[#}
				"forceExit" -> {#]
				forward waiter -m listenRequests : listenRequests(1)
				forward resourcemodel -m taskDone : taskDone($WhatImDoing,$TeatableNumber)
			[#}
				
				"returnHome" -> {
					// sono a casa
				ReturningHome = false #]
				forward waiter -m listenRequests : listenRequests(1)
				forward resourcemodel -m taskDone : taskDone($WhatImDoing,$Misc) 
			[#}
				else -> {
			#]
				forward waiter -m listenRequests : listenRequests(1)
				forward resourcemodel -m taskDone : taskDone($WhatImDoing,$Misc)
			[#}
			}#]
		}
	}	Transition t1 	whenMsg moveTo -> movementHelper  
						whenMsg order -> takingOrder
						whenMsg payment -> handlePayment
						whenMsg cleanTable -> cleaningTable
						whenMsg listenRequests -> reqHandler
						whenMsg alarm -> handleAlarm
						whenReply atcell -> handleAtCell
						
	
}



QActor planner context ctxtearoom{  
[#
	var XT = "0"
	var YT = "0"
	var CurrentPlannedMove = ""
	var StepTime    	   = 100L
	var Configured = false
	var SingleMove = false
	var StopTask = false
#]
	State s0 initial {	     
		println("[PLANNER] Waiting requests")
		if [# !Configured #] {
			[# Configured = true #]
			run itunibo.planner.plannerUtil.initAI()
			run itunibo.planner.plannerUtil.loadRoomMap( "teaRoomExplored" )
			discardMsg Off
		}
		[# SingleMove = false #]
		[# StopTask = false #]
	}	
	Transition t0 	whenRequest movetoCell -> walk
					whenMsg doMove  -> execSingleMove
	
	State execSingleMove {
		// esecuzione singola mossa
		[# SingleMove = true #]
		onMsg( doMove : doMove(M) ){ 	
  			if [# payloadArg(0) == "w" #] {
  				request basicrobot -m step : step(370)
  			} else {
  				forward basicrobot -m cmd : cmd($payloadArg(0))
  				delay 500	
  			}
  		}
  		[# 
  			val move = payloadArg(0)
  			itunibo.planner.plannerUtil.updateMap(move,"")
  		#]	
	}Goto updateCurrentWaiterPosDir if [# payloadArg(0) != "w" #] else waitStepDoneFail
	
	
	State walk{
		[# StopTask = false #]
		onMsg( movetoCell : movetoCell(X,Y) ){
			[# XT = payloadArg(0)
			   YT = payloadArg(1)			  
			 #]
			println("[PLANNER] MOVING to ($XT,$YT)")
			run itunibo.planner.plannerUtil.planForGoal("$XT","$YT")
		}
	}
	Goto execPlannedMoves
	
	
	State execPlannedMoves{ 
 		[#  CurrentPlannedMove = itunibo.planner.plannerUtil.getNextPlannedMove() #]
 		if [# CurrentPlannedMove.length > 0 # ]{
 			forward planner -m doMove : doMove($CurrentPlannedMove)
 		}else{
		     println("[PLANNER] POINT ($XT,$YT) REACHED")
		     replyTo movetoCell with atcell : atcell($XT,$YT) 		
 		}
 	}
 	Transition t0 	whenMsg stopTask -> handleStop
 					whenMsg doMove  -> execTheMove
 					whenRequest movetoCell and [# CurrentPlannedMove.length == 0 #]-> walk
 				  
 	State handleStop {
 		// ho fermato un task di movimento
 		[# 
 			StopTask = true 
 			itunibo.planner.plannerUtil.resetActions()
 		#]	
 	}Transition t0 	whenMsg doMove  -> execTheMove
 					whenRequest movetoCell and [# CurrentPlannedMove.length == 0 #]-> walk
 	State execTheMove{ 
  		onMsg( doMove : doMove(M) ){ 	
  			if [# payloadArg(0) == "w" #] {
  				request basicrobot -m step : step(370)
  			} else {
  				forward basicrobot -m cmd : cmd($payloadArg(0))
  				delay 500	
  			}
  		}
  		[# 
  			val move = payloadArg(0)
  			itunibo.planner.plannerUtil.updateMap(move,"")
  		#]		 			
 	 } 
     Goto updateCurrentWaiterPosDir if [# payloadArg(0) != "w" #] else waitStepDoneFail
     
     State waitStepDoneFail {
     } Transition t1 	whenReply stepdone -> updateCurrentWaiterPosDir
     					whenReply stepfail -> updateCurrentWaiterPosDir
     					
     State updateCurrentWaiterPosDir {
     	[# 
     		val X = itunibo.planner.plannerUtil.getPosX()
     		val Y = itunibo.planner.plannerUtil.getPosY()
     		val Direction = itunibo.planner.plannerUtil.getDirection()
     	#]
     	forward resourcemodel -m waiterCurrentPositionDirection : waiterCurrentPositionDirection($X,$Y,$Direction)
     }Goto execPlannedMoves if [# !SingleMove && !StopTask #] else s0 
      
}
 



QActor smartbell context ctxtearoom{  
	[#  
		var T     = 37.0
	#]   
	  
	State s0 initial {	     
 		discardMsg Off
 	} 
	Goto  waitingForClient  
	
	State waitingForClient{
		println("[SMARTBELL] Waiting for a new client...")
 	} 
	Transition t0 whenRequest notify      -> checkTemp // nuovo cliente

	State checkTemp{ 
		onMsg(notify : notify(T)) {
			// controllo temperatura
			[# T = payloadArg(0).toDouble() #]
	 		println("[SMARTBELL] Checking your temperature...")
	 		if[# T > 37.5 #]{
	 			println("[SMARTBELL] You should go to the hospital! ")
   				replyTo notify with tempResult : tempResult(no) 
	 		} else {
	 			println("[SMARTBELL] Your temperature is ok ")
   				replyTo notify with tempResult : tempResult(yes)
	 		}
 		}
 	}
 	Goto waitingForClient if [# T > 37.5 #] else waiterInfo

 	
 	State waiterInfo {  
 		println("[SMARTBELL] Checking table situation... ")
 		forward resourcemodel -m newClient : newClient(0)
 	}
    Transition t1 	whenEvent waitingTimeEvent -> informClient
    				
 	
 	State informClient{
 		onMsg(waitingTimeEvent : waitingTimeEvent(ID,X)){
  			if [# payloadArg(1).toDouble() == 0.0 	#] {
  				println("[SMARTBELL] A waiter is coming... ")
  				forward clientsmanager -m accept : accept($payloadArg(0))
  			} else {
  				println("[SMARTBELL] You have to wait... ")
  				forward clientsmanager -m inform : inform($payloadArg(0),$payloadArg(1))
  			}
  		}
 	}   
 	Goto waitingForClient 
 	
}

QActor barman context ctxtearoom{  
	
	[#var ID = ""#]
	  	  
	State s0 initial {	     
 		discardMsg Off
 	} 
	Goto  waitingForOrder 
	
	State waitingForOrder{
		println("[BARMAN] Waiting for events...")
 	} 
	Transition t0 whenEvent newOrderEvent -> makeTea
					whenEvent prepare -> teaReady

	State makeTea{ 
		onMsg(newOrderEvent : newOrderEvent(ID)) {
			[#ID = payloadArg(0)#]
	 		println("[BARMAN] Making some delicious tea...")
 		}
 	}
 	Goto waitingForOrder
 
 	State teaReady{   
 		onMsg(prepare : prepare(ID)) {
 			[# ID = payloadArg(0) #]
			println("[BARMAN] The order for client $ID is ready!")
   			forward resourcemodel -m ready : ready($ID)
   		}
  	}
	Goto waitingForOrder
		 	
} 

QActor clientsmanager context ctxtearoom {
	[# 
		var tempResult = ""	
		var ID = ""
		var Temperature = 0.0
	#]
	
	State init initial {
		println("[CLIENT MANAGER] Client Manager STARTED")
		discardMsg Off
	}Goto waitingMsg
	
	State waitingMsg {
	}Transition t0  whenEvent newClient -> newClientState
					whenEvent nextState -> retrieveClientState
					whenMsg alarm -> handleAlarm
	
	State handleAlarm {
		// timer max waiting time scattato
		onMsg(alarm : alarm(ID)) {
			[# var ID = payloadArg(0) #]
			request resourcemodel -m clientStateReq : clientStateReq($ID)
		}
	}Transition t0 whenReply clientStateRep -> stayOrLeave // chiedo lo stato del cliente
	
	State stayOrLeave {
		onMsg(clientStateRep : clientStateRep(ID, CurrentState)) {
			[# 
				var ID = payloadArg(0)
				var CurrentState = payloadArg(1) 
				if(CurrentState == "waiting"){ // solo se il cliente sta ancora aspettando lo faccio andare via
					println("[CLIENT $ID] Bye!")
				 #] forward resourcemodel -m updateClientState : updateClientState($ID,withdraw) [#
				}
			#]
		}
	}Goto waitingMsg
					
	
	// newClient operazione atomica
	
	State newClientState {
		println("[CLIENT MANAGER] A new client is here!")
		[# if(Math.random() < 0.95) {
			Temperature = 36.0
		} else {
			Temperature = 39.0
		}#]
		request smartbell -m notify : notify($Temperature)
	}Transition t0 whenReply tempResult -> handleReply
	
	
	State handleReply {
		onMsg(tempResult : tempResult(RES)){
			[# tempResult = payloadArg(0) #]
		}
	}Goto waitToEnter if [# tempResult == "yes" #] else exit
	
	State waitToEnter {
	}Transition t1 	whenMsg inform -> wait
					whenMsg accept -> enter

	State wait {
		println("[POSSIBLE CLIENT] I have to wait")
		onMsg(inform : inform(ID,TIME)){
			[# var Time = payloadArg(1).toLong() 
				ID = payloadArg(0)
			#]
			forward timersmanager -m startTimer : startTimer(0,clientsmanager, alarm, $ID, $Time)
		}
	}Goto waitingMsg
	
	State enter {
		onMsg(accept : accept(ID)){
			[# 
				ID = payloadArg(0)
			#]
		}
	}Goto waitingMsg
	
	// fine newClient
	
	State retrieveClientState {
		// progressione nello stato del cliente
		onMsg(nextState : nextState(ID)) {
			[# ID = payloadArg(0) #]
			request resourcemodel -m clientStateReq : clientStateReq($ID)
		}
	}Transition t0 whenReply clientStateRep -> progressClientState
	
	State progressClientState {
		onMsg(clientStateRep : clientStateRep(ID, CurrentState)) {
			[# 
				var ID = payloadArg(0)
				var CurrentState = payloadArg(1) 
				var NextState = ""
				when(CurrentState) {
					"entering" -> {
						NextState = "ordering"
						println("[CLIENT $ID] I want to order!")
					}
					"ordering" -> {
						// ordino
						#] forward waiter -m order	: order($ID,tea) [#
						NextState = "waitingtea"
						println("[CLIENT $ID] A Na-tea-li please!")
					}
					"waitingtea" -> {
						NextState = "drinking"
						println("[CLIENT $ID] Delicious tea!")
					}
					"drinking" -> {
						NextState = "paying"
						println("[CLIENT $ID] I want to pay!")
					}
					"paying" -> {
						// pago
						#] forward waiter -m payment : payment($ID,10) [#
						NextState = "exiting"
						println("[CLIENT $ID] Exiting!")
					}
					"exiting" -> {
						NextState = "gone"
						println("[CLIENT $ID] Bye!")
					}
					"waiting" -> {
						NextState = "gone"
						println("[CLIENT $ID] Bye!")
					}
				}
			#]
			forward resourcemodel -m updateClientState : updateClientState($ID,$NextState)
			
		}
	}Goto waitingMsg
	
	State exit {
		println("[POSSIBLE CLIENT] Maybe next time. Bye!")
	}Goto waitingMsg
	
	
}

QActor timersmanager context ctxtearoom {
	// salvo timer attivi
	[# var timersDict =  mutableMapOf<String, kotlinx.coroutines.Job>() #]
	
	State s0 initial {
		discardMsg Off
	}Goto waitingRequests
	
	State waitingRequests{ println("[TIMERS MANAGER] Waiting for new requests")}
	Transition t0 whenMsg startTimer -> timer
					whenMsg cancelTimer -> timer
	
	State timer {
		onMsg(startTimer : startTimer(ID,A,M,P,T)) {
			println("[TIMERS MANAGER] Starting timer")
			[#
				var ID = payloadArg(0)
				var Actor = payloadArg(1)
				var Message = payloadArg(2)
				var Payload = payloadArg(3)
				var Time = payloadArg(4).toLong()
				// se ID arrivato è uguale a 0, lo creo io
				if(ID == "0") {
					ID = Math.random().toString()
				}
				timersDict.put(ID, scope.launch {
					delay(Time)
					forward("$Message", "$Message($Payload)" ,"$Actor" )		
				})
			#]	
		}
		onMsg(cancelTimer : cancelTimer(ID)) {
			println("[TIMERS MANAGER] Cancelling timer")
			[#
				var ID = payloadArg(0) 
				timersDict.get(ID)?.cancel() 
			#]
		}
	}Goto waitingRequests
}


 